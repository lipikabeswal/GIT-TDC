<view name="magnifyingGlass" id="gMagnifyingGlass"
	x="$once{canvas.width/2 - this.width/2}" valign="middle" width="320"
	height="128" bgcolor="gray" visible="false">
	<dragstate name="dragger" drag_axis="both" drag_min_x="0"
		drag_max_x="$once{canvas.width - this.width}" drag_min_y="0"
		drag_max_y="$once{canvas.height - this.height}" />
	<attribute name="bg" type="color" value="0xFFD700" />
	<attribute name="fg" type="color" value="0xE0E0E0" />

	<attribute name="trackDel"
		value="$once{new LzDelegate( this , 'mouseMove' ) }" />
	<attribute name="lastxpos" value="0" type="number" />
	<attribute name="lastypos" value="0" type="number" />
	<attribute name="isEnabled" value="false" />

	<method event="oninit">
			this.windowbg.drawMe();
	</method>

	<method event="onvisible">
		this.setX(canvas.width / 2 - this.width / 2);
		this.ratioW = this.width/(canvas.width + this.width);
		this.ratioH = this.height/(canvas.height + this.height);
	</method>

	<view name="handle" x="${parent.width -27}"
		y="${parent.height -27}" resource="magnifierHandle" />

	<drawview name="windowbg" width="${parent.width}"
		height="${parent.height}">

		<method name="drawMe">
			this.clear();
			var roundness = 5;
			var thickness = 3;
			var shadow = 4;
			this.changeColor(parent.bg, parent.fg);
		</method>

		<method name="changeColor" args="bgcolor, fgcolor">
            var roundness = 5;
            var thickness = 0;
			Debug.write("changecolor", this.width,this.height);
            drawRoundRect (thickness, thickness, this.width, this.height, 
                           roundness,
                           bgcolor, fgcolor, 1);
        </method>

		<method name="drawRoundRect"
			args="x0, y0, x1, y1, roundness, fill, stroke, alpha">
			
            this.beginPath();
            this.rect(x0 , y0 , x1 , y1 , roundness);

            this.closePath();
            this.setAttribute("globalAlpha", alpha);

            if (fill) {
                this.setAttribute("fillStyle", fill);
                this.fill();
            }
            if (stroke) {
                this.setAttribute("strokeStyle", stroke);
                this.stroke();
            }
        </method>

		<method event="onmousedown">
			Debug.write("startTracking");
		    magnifyingGlass.dragger.apply();
			magnifyingGlass.mouseMove();
			LzCursor.setCursorGlobal ('grabbing_cursor');
		    LzCursor.lock();		
		</method>

		<method event="onmouseup">
	        magnifyingGlass.dragger.remove();
			LzTimer.removeTimer(magnifyingGlass.trackDel);
			LzCursor.unlock();
	        gController.restoreCurrentCursor();
  		</method>

		<view name="magnifiedContent" x="5" y="5"
			width="${parent.width - 10}" height="${parent.height - 10}"
			bgcolor="gray" opacity="1" resource="magnifierBlank" />

	</drawview>

	<method name="setUpGlass">
		 this.setAttribute("visible", true);	
		 this.setAttribute("x",canvas.width/2 - this.width/2);
		 this.setAttribute("valign",'middle');
	</method>

	<method name="hideGlass">
		Debug.write("hideglass called");
		this.setAttribute("visible", false);
	</method>

	<method name="mouseMove">
            <![CDATA[
            var xpos = Math.round( canvas.getMouse("x") );
            var ypos = Math.round( canvas.getMouse("y") );
			var temp_mc = this.windowbg.magnifiedContent.getMCRef();

			var colorTransform = new flash.geom.ColorTransform();
			var rect = new flash.geom.Rectangle(0, 0, this.width, this.height);
			var mainView_mc = canvas.titleView.getMCRef();
			var scale = 1.5;
			var x;
			var y;
			var w;
			var h;
			var bitmap;
			var matrix = new flash.geom.Matrix();
            if ( (this.lastxpos != xpos) 
              || (this.lastypos != ypos) ) {
                this.lastxpos = xpos;
                this.lastypos = ypos;
				
				x = this.x;
				y = this.y;
		
				w = this.width - 10;
				h = this.height - 10;
				bitmap = new flash.display.BitmapData(w, h, false);
				matrix.scale(scale, scale);
				matrix.translate(-x * (scale + this.ratioW), -y * (scale + this.ratioH) );
				bitmap.draw(mainView_mc, matrix, colorTransform, 1, rect);
				temp_mc.attachBitmap(bitmap,1);
				bitmap = null;
		    }
			LzTimer.resetTimer(trackDel, 25); 
            ]]>
	</method>

</view>

