<library>
	<include href="CachableComponent.lzx" />
	<include href="../../../resources/resources.lzx" />

	<!-- ************************************
		CachableRecorder
		
		A Cachable Recorder Widget for recording student's 
		voice as a response to an Audio item.  
		*************************************-->

	<class name="CachableRecorder" extends="CachableComponent"
		comptype="${gCompTypes.WIDGET_RECORDER}" aaactive="true"
		aasilent="false">		

		<attribute name="blinkerDel"
			value="$once{new lz.Delegate(this,'blinker')}" type="expression"/>
		<attribute name="countDownDel"
			value="$once{new lz.Delegate(this,'countDownTimer')}" type="expression"/>
		<attribute name="defaultTotalTime" value="90" />
		<attribute name="totalTime" value="90" />
		<attribute name="recordStarted" type="boolean" value="false" />
		// added for Mic calibration screen.
		<attribute name="playStarted" type="boolean" value="false" />
		<attribute name="increment" type="boolean" value="0" />

		<attribute name="width" value="250" />
		<attribute name="height" value="150" />

		<attribute name="defaultWidth" value="250" />
		<attribute name="defaultHeight" value="150" />

		<attribute name="bgcolor" value="0x6F0F0F" /><!-- iceblue -->

		<attribute name="recordButton" />
		<attribute name="stopButton" />
		<attribute name="resetButton" />
		<attribute name="playButton" />
		<attribute name="bar" />
		<attribute name="barfilled" />
		<attribute name="timertext" />
		<attribute name="meterContainer" />
		<attribute name="volumeMeter" />
		<attribute name="micNotConnected" />
		<attribute name="recordIconsView" />
		<attribute name="attachMic" />
		<attribute name="recordStatus" />
		<attribute name="widgetbuttons" />
		<attribute name="red" />
		<attribute name="green" />
		<attribute name="allow_revisit" type="boolean" value="false" />
		<attribute name="widget_id" value="widget10000000000"
			type="string" />
		<attribute name="leveldel"
			value="$once{new lz.Delegate(this, 'updateLevel')}" type="expression"/>
		<!-- For LLO128-->
		<attribute name="linuxLevelDel"
			value="$once{new lz.Delegate(this, 'updateLinux')}" type="expression"/>
		<attribute name="level" type="number" value="0" />
		<attribute name="activityArray" value="$once{new Array()}" />
<attribute name="fakeActivityArray" value="$once{new Array()}" />
		<!--<attribute name="countlevel" type="number" value="0" />-->
		<attribute name="recordState" type="number" value="0" />	
		<attribute name="factor" type="number" value="1" /><!-- for flexible recorder -->
		<attribute name="micState" type="boolean" value="false"/>
		<attribute name="stopCalled" type="boolean" value="false"/>
		<attribute name="blinkerVal" type="number" value="0"/>
		<attribute name="recordingCounter" type="number" value="1"/>
		<attribute name="resetCalled" type="boolean" value="false"/>
		<!-- For LLO128-->
		<attribute name="requestSent" type="boolean" value="false"/>
		<attribute name="micConnected" type="boolean" value="false"/>
		<attribute name="mc"/>
		<attribute name="myMic"/>

<attribute name="drecordDel"
			value="$once{ new lz.Delegate( this, 'callRecordMethod' ) }" />
<attribute name="startRecord" type="boolean" value="false" />
<attribute name="startRecordDel"
			value="$once{new lz.Delegate(this,'setStartRecord')}" type="expression"/>

		<dataset name="audioDset"
			ondata="classroot.handleResponseData(this.data)" type="http"
			onerror="classroot.requestError(this)" request="false">
		</dataset>

		<method name="init">
			console.log("Inside init");
			super.init();
			gController.setAttribute('resetButtonEnable',false);
			setReferences();
		</method>

		<handler name="oninit">
			//console.log("Inside oninit");
			this.timertext.setAttribute('text',this.totalTime);
			this.setAttribute('width', this.width*factor);
			this.setAttribute('height', this.height*factor);
		

		</handler>

		<handler name="ondata" args="data"><![CDATA[
			//console.log("Inside ondata");
			this.resetCalled=false;
			this.requestSent = false;
			this.blinkerVal = 0;
			this.reset('ignore');
			//for setting the background color

			var style = gController.getAccomStyleForType ("stem");
            if(style && style.bgcolor != null && style.bgcolor != ""){
            	this.parent.setAttribute ('bgcolor', style.bgcolor);
            }
            else {
            	this.parent.setAttribute ('bgcolor', gController.questionBgColor);
            }
			Debug.write("style.data..." , data);
			
			
			if(data.getAttr('x')) {
				this.setAttribute('x', Number(data.getAttr('x')));
			}
			
			if(data.getAttr('y')) {
				this.setAttribute('y', Number(data.getAttr('y')));
			}
			
			if(data.getAttr('id')){
				this.setAttribute('widget_id', data.getAttr('id'));
			}
			
			if(data.getAttr('allow_revisit')){
				this.setAttribute('allow_revisit', data.getAttr('allow_revisit'));
			}
			
			if(data.getAttr('totalTime')){
				this.setAttribute('totalTime', data.getAttr('totalTime'));		
				this.setAttribute('defaultTotalTime', data.getAttr('totalTime'));
				this.timertext.setAttribute('text',this.totalTime);		
			}

			var answered = false;
			gController.addAudioItem({"widget_id" : this.widget_id, "answered" : answered});
			gController.setAttribute('blockFileName' , true);
			doneLoading();
			gController.recorderComponent(this);

			//console.log("this.isinited "+this.isinited+" this.visible "+this.visible);
			if(this.isinited && this.visible){
				getActivityLevel();
			}
			// For LLO128
			//var os =  isLinux();
				
			/*if(this.isinited && this.visible && !isLinux()) {
				this.myMic = lz.FlashUtils.getObject();
				Debug.write("this.myMic", this.myMic);
				if(this.myMic != null) {
					this.myMic.gain = 100;
					this.myMic.rate = 11;
					this.myMic.setSilenceLevel(0);
					this.myMic.setLoopBack(true);
					this.myMic.setUseEchoSuppression(true); 
					
					//lz.FlashUtils.registerMic()
				}
			}*/
			
		]]>
		</handler>


		<method name="doneLoading"><![CDATA[	
		//console.log("Inside doneLoading");
			//Debug.write("parent.width = "+parent.width);
			//Debug.write("this.width = " + this.width);
			
			if(gController.hasFontAccommodation) {	
			//Debug.write("gController.hasFontAccommodation = " + gController.hasFontAccommodation);
				//if(this.width >= parent.width)
				//{
				//	this.setAttribute('width', parent.width);
				//	this.setAttribute('height', this.defaultHeight);
				//	this.setAttribute('factor', 1 );
				//}
				//else{
					this.setAttribute('factor',1.5);
					this.setAttribute('width', this.defaultWidth * this.factor);
					this.setAttribute('height', this.defaultHeight * this.factor);
				//}
			}
            super.doneLoading();
        ]]></method>
        <!-- For LLO128-->
		<method name="isLinux">
		//Debug.write("isLinux fired");
		/*var os = flashSystem.capabilities.os;
		os = os.split(" ");
//Debug.write("os name : ",os);
		if(os[0] == 'ubuntu' || os[0] == 'Fedora' || os[0] == 'Redhat' || os[0] == 'Linux' || os[0] == 'solaris'){
		return true;
		}
		return false;*/
		</method>

		<method name="isVista">
		//Debug.write("isLinux fired");
		/*var os = flashSystem.capabilities.os;
		os = os.split(" ");
//Debug.write("os name : ",os);
		if(os[1] == 'Vista'){
		return true;
		}
		return false;*/
		</method>

		<method name="doReturnToCache"><![CDATA[
			//console.log("Inside doReturnToCache");
			//Debug.write("doreturn to cache");
			this.stopblinker('stop');
			/*if(!isLinux()){
				//this.getMCRef().attachAudio(false);
			}*/
			audioDset.abort();
			/*if(!isLinux())
			lz.Timer.removeTimer(leveldel);
			else*/
			lz.Timer.resetTimer(linuxLevelDel, 100);
       ]]></method>

		<view name="main" align="center" valign="middle"
			width="${parent.width - 3}" height="${parent.height - 3}">
			<simplelayout axis="y" spacing="0"/>
			<view name="header" width="100%" height="15%"
				bgcolor="0x3F1F0F">
				<simplelayout axis="x" spacing="5"/>
				<view resource="heading_microphone" stretches="both"
					width="${parent.height}" height="${parent.height-2}">
				</view>
				<text valign="middle" font="CTB" fontsize="${12 * classroot.factor}"
					fontstyle="bold" fgcolor="white" width="90%" height ="100%">
					Sound Recorder
					<handler name="ontext">
						if(gController.dplang.xpathQuery("component[@name='Recorder']") != null){
							var labelText = gController.dplang.xpathQuery("component[@name='Recorder']/labelText").childNodes[0].data;
							this.setAttribute('text',labelText);
						}
					</handler>
					
				</text>
			</view>
			<view name="content" width="100%" height="85%" bgcolor="white">
				<simplelayout axis="y" spacing="2"/>
				<view name="recorddisplay" align="left" width="100%">
					<simplelayout axis="x" spacing="1" />

					<view name="recordicons" height="${40 * classroot.factor}">
						<view name="meterContainer" x="${parent.parent.parent.bar.x}"
							y="${11 * classroot.factor}" width="${41 * classroot.factor}" resource="volume_meter" height="35">
							<view name="volumebar" x="0" y="0"
								width="${41 * classroot.factor}" height="$once{parent.height}" resource="volume_meter_flip"
								opacity=".7" bgcolor="white" clip="true">
							</view>
						</view>

						<view name="red" opacity=".7" visible="false"
							x="${parent.parent.parent.bar.width/2}" resource="record_bullet_red" y="${11 * classroot.factor}"
							stretches="both" width="${15 * classroot.factor}" height="${15 * classroot.factor}"
							valign="middle">

						</view>
						<view name="green" opacity=".7" visible="false" y="${11 * classroot.factor}"
							x="${gMicCalibrationScreen.visible?((parent.parent.parent.bar.width/2)- 8):parent.parent.parent.bar.width/2}" resource="record_bullet_green"
							stretches="both" width="${parent.red.width}"
							height="${parent.red.height}" valign="middle">
						</view>
						<view name="redReplace" visible="false" bgcolor="white"
							x="${parent.parent.parent.bar.width/2}" y="${11 * classroot.factor}"
							width="${15 * classroot.factor}" height="${15 * classroot.factor}"
							valign="middle">

					</view>
					</view>

					<view name="showStatus" y="${9 * classroot.factor}" x="0" width="${20 * classroot.factor}" height="${40 * classroot.factor}">
						<text name="recordStatus" fontsize="${12 * classroot.factor}"
							font="CTB" resize="true" fontstyle="bold" height="100%">
						<handler name="ontext"><![CDATA[
							var elm1 = getDisplayObject();
							elm1.setAttribute('style','font-family: CTB; font-weight: bold; font-size: '+this.fontsize+'; pointer-events: none;  width: auto;');
						]]></handler>
						</text>
					</view>
				</view>

				<view name="recordtimer" x="${parent.bar.x + parent.bar.width - parent.recordtimer.width}"
					y="${parent.bar.y - parent.recordtimer.height}" height="${20 * classroot.factor}" width="100%">
					<resizelayout axis="x" />
					<view options="releasetolayout" height="100%">
					</view>
					<text name="remaining" fontsize="${12 * classroot.factor}" font="CTB" fontstyle="bold"
						valign="bottom" height="100%">
						TIME REMAINING:
						<!-- Changes for Defect #79448 -->
						<handler name="oninit">
							var elm = this.getDisplayObject();
							if(gController.language.indexOf("Spanish") >= 0){
								elm.style.width="auto";
							}
						</handler>
						<handler name="ontext">
						if(gController.dplang.xpathQuery("component[@name='Recorder']") != null){
							var timeLeft = gController.dplang.xpathQuery("component[@name='Recorder']/remaining").childNodes[0].data;
							this.setAttribute('text',timeLeft);
						}
						var elm = this.getDisplayObject();
						if(gController.language.indexOf("Spanish") >= 0){
							//elm.setAttribute('style','font-family:CTB; width:auto;font-weight:bold;left:7px;'); //commented to fix Defect #79448 the functionality is moved to oninit handler
						}
						
					</handler>
					
					</text>
					<text name="timertext" fontsize="${12 * classroot.factor}" fontstyle="bold"
						font="CTB" fgcolor="0x008000"  valign="bottom" height="100%" >
						
						<handler name="ontext"><![CDATA[
							var elm = getDisplayObject();
							elm.setAttribute('style','font-family: CTB; white-space: nowrap; font-weight: bold; font-size: '+this.fontsize+'; pointer-events: none; height: 16px; width: auto;');
						]]></handler>
                        
						
			<!--			<handler name="ontext"><![CDATA[
							console.log("===ONTEXT===",this.text.length);
							if(this.text.length == 2){
							console.log("===ONTEXT 2===",this.text.length);
								this.setAttribute('width',16);
							}else{
							console.log("===ONTEXT 3===",this.text.length);
								this.setAttribute('width',22);
							}
						]]></handler> -->
					</text>
					<text fontsize="${12 * classroot.factor}" font="CTB"  fontstyle="bold"
						valign="bottom" height="100%" width="15%">
						secs
						<handler name="ontext">
							if(gController.dplang.xpathQuery("component[@name='Recorder']") != null){
								var secsText = gController.dplang.xpathQuery("component[@name='Recorder']/secs_text").childNodes[0].data;
								this.setAttribute('text',secsText);
						}
						</handler>
					</text>
				</view>
				<view name="bar" align="center" width="80%" height="${6 * classroot.factor}"
					bgcolor="0xcccccc">
					<view name="barfilled" width="0" height="100%"
						bgcolor="0x328693">
					</view>
				</view>

				<view name="justforspace" align="center" width="100%"
					height="10%">
				</view>
				<view name="widgetbuttons" width="100%" height="18%">
					<view name="whitewrapper" height="100%"
						bgcolor="white" x="${parent.parent.bar.x}" >
						<!--simplelayout axis="x" spacing="65" /-->
						<view name="buttons">
							<simplelayout axis="x" spacing="6" />
							<basebutton resource="button_record"
								name="recordButton" width="${23 * classroot.factor}" height="${23 * classroot.factor}" stretches="both"
								align="left" onclick="classroot.startblinker('record')" >
								<handler name="onmouseover">
									if(gController.dplang.xpathQuery("component[@name='Recorder']") != null){
										// Setting tootip text based on language.
										var tooltipText = gController.dplang.xpathQuery("component[@name='Recorder']/tooltip_record").childNodes[0].data;
										if(gMicCalibrationScreen.visible){
											gTooltip_new.showTooltip(tooltipText);
										}else{
											gTooltip.showTooltip(tooltipText);
										}
									}else{
										gTooltip.showTooltip('Record');
									}
								</handler>						                
								<handler name="onmouseout">
									if(gMicCalibrationScreen.visible){
										gTooltip_new.hideTooltip ();   
									}else{
										gTooltip.hideTooltip (); 
									} 
								</handler>
								<!--<handler name="onmousedown"><![CDATA[
									if(gController.isMicPresent == true || gController.isMicPresent == 'true'){
										this.setAttribute('clickable',true);
										classroot.whitewrapperOverLay.setAttribute('visible',false);
									}
									else{
										this.setAttribute('clickable',false);
										classroot.whitewrapperOverLay.setAttribute('visible',true);
									}
								]]>
								</handler>
								 <tooltip>Record</tooltip> -->
							</basebutton>
							<basebutton resource="button_play" clickable="true" name="playButton"
								width="${parent.recordButton.width}" height="${parent.recordButton.height}" stretches="both"
								enabled="false" onclick="classroot.startPlay('play')" visible="${gMicCalibrationScreen.visible}">
								<handler name="onmouseover">
										if(gController.dplang.xpathQuery("component[@name='Recorder']") != null){
										// Setting tootip text based on language.
										var tooltipText = gController.dplang.xpathQuery("component[@name='Recorder']/tooltip_play").childNodes[0].data;
										if(gMicCalibrationScreen.visible){
											gTooltip_new.showTooltip(tooltipText);
										}else{
											gTooltip.showTooltip(tooltipText);
										}
									}else{
										gTooltip.showTooltip('Play');
									}
								</handler>						                
								<handler name="onmouseout">
									gTooltip_new.hideTooltip ();
								</handler>
							</basebutton>
							<basebutton resource="button_stop"
								name="stopButton" width="${parent.recordButton.width}" height="${parent.recordButton.height}" stretches="both"
								enabled="false" onclick="classroot.stopblinker('stop')" >
							 	<handler name="onmouseover">
									if(gController.dplang.xpathQuery("component[@name='Recorder']") != null){
										// Setting tootip text based on language.
										var tooltipText = gController.dplang.xpathQuery("component[@name='Recorder']/tooltip_stop").childNodes[0].data;
										if(gMicCalibrationScreen.visible){
											gTooltip_new.showTooltip(tooltipText);
										}else{
											gTooltip.showTooltip(tooltipText);
										}
									}else{
										gTooltip.showTooltip('Stop');
									}
								</handler>						                
								<handler name="onmouseout">
									if(gMicCalibrationScreen.visible){
											gTooltip_new.hideTooltip();
										}else{
											gTooltip.hideTooltip();   
										}
								</handler>
								<!--<tooltip>Stop</tooltip>-->
							</basebutton>
						</view>
						<view name="startOver" x="${parent.parent.parent.bar.width - parent.startOver.width}">
							<basebutton x="${gController.language=='Spanish'?-10:0}"
								name="resetButton" resource="${gController.language=='Spanish'?'button_startover_spanish':'button_startover_english'}" width="${gController.language=='Spanish'?75:60}" height="${20 * classroot.factor}" stretches="both"
								enabled="false" onclick="classroot.reset('reset')" >
								<handler name="onmouseover">
									if(gController.dplang.xpathQuery("component[@name='Recorder']") != null){
										// Setting tootip text based on language.
										var tooltipText = gController.dplang.xpathQuery("component[@name='Recorder']/tooltip_startOver").childNodes[0].data;
										if(gMicCalibrationScreen.visible){
											gTooltip_new.showTooltip(tooltipText);
										}else{
											gTooltip.showTooltip(tooltipText);
										}
									}else{
										gTooltip.showTooltip('Start Over');
									}
								</handler>						                
								<handler name="onmouseout">
									if(gMicCalibrationScreen.visible){
											gTooltip_new.hideTooltip ();    
										}else{
											gTooltip.hideTooltip ();    
										}
								</handler>
								<!-- <tooltip>Start Over</tooltip> -->
							</basebutton>
						</view>
						</view>
				</view>

				<view name="justforspace2" align="center" width="100%"
					height="10%">
				</view>
			</view>
		</view>
		<view name="whitewrapperOverLay" bgcolor="white" x="2"
			y="${parent.y + 35}"
			height="${parent.height - 40}" width="${parent.width - 5}"
			clickable="true" showhandcursor="false" visible="false">
			<simplelayout axis="x" inset="10" spacing="10" />
			<view name="micNotConnected" valign="middle"
				resource="mic_not_connected" stretches="both" width="${36 * classroot.factor}" height="${34 * classroot.factor}">
			</view>
			<text name="attachMic" fontsize="${12 * classroot.factor}" font="CTB"
				valign="middle" multiline="true" width="${parent.width - parent.attachMic.x}">
				It appears your microphone is not plugged in, 
				please adjust your microphone input volume up 
				and make sure your microphone is connected.
				<handler name="ontext">
					if(gController.dplang.xpathQuery("component[@name='Recorder']") != null){
						var attachMicText = gController.dplang.xpathQuery("component[@name='Recorder']/attachMic").childNodes[0].data;
						this.setAttribute('text',attachMicText);
					}
				</handler>
			</text>
		</view>
		
		<view name="blackOverLay" bgcolor="black" x="${parent.main.x}"
			y="${parent.main.y}" opacity="0.5"
			height="${parent.height}" width="${parent.width}"
			clickable="true" showhandcursor="false" visible="false" >
		</view>

		<method name="startblinker" args="methodname"><![CDATA[
		//console.log("Inside startblinker");
			//blockUI(this);
			if(gController.microphoneLevel > 0){
				gTooltip_new.hideTooltip ()
				gRecordingPopup.show();
			}
			//gController.resetMicCheck();
			this.stopCalled = false;		//to re-use this attribute, reset it
			gController.disableAllAssets();
			this.blinkerVal = 0;
			if(this.resetCalled == true){
				gController.setAttribute('recordState',false);
			}
			if(!this.recordStarted) {
				if(!isLinux()){	
				this.updateLevel();	
				}/*else{
				//Debug.write("Update level linux");
				this.updateLinux();
				//}
				//playProgress(methodname);//put delay of 500 miliseconds
				/*if(gController.isaudio){
					gController.disableAllAudio();
				}*/
				setRecordDelegate();
				//lz.Timer.resetTimer(drecordDel, 300);
				//callRecordMethod();
			}		
		]]></method>

		<method name="callRecordMethod">
			//console.log("callRecordMethod.....");	
			playProgress('record');
			//lz.Timer.resetTimer(drecordDel, 300);
		</method>		

		<method name="setRecordDelegate">
			//console.log("Inside setRecordDelegate");
			if(typeof this.recordDel == "undefined") {	
				this.recordDel = new lz.Delegate(this, "callRecordMethod");
			}
			lz.Timer.resetTimer(this.recordDel, 300);
		</method>		
		
		<method name="playProgress" args="methodname"><![CDATA[
			//console.log("Inside playProgress");
		//micState will be set by updateLevel method
			if(gController.microphoneLevel > 0){
				this.recordStarted = true;		//if mic is connected, then only set this attribute to true 
				this.stopCalled = false;
				//classroot.whitewrapperOverLay.setAttribute('visible',false);
			if(this.requestSent == false){
					//console.log("requestSent :"+this.requestSent);
					this.requestSent = true;
					sendRequest(methodname);
				}		
				this.increment = bar.width / this.defaultTotalTime;
				this.recordButton.setAttribute("enabled", false);
				
				//this.playButton.setAttribute("enabled", false);
				//console.log("setting green to false 4");
				//this.green.setAttribute('visible',false);
				//gController.updateAudioField(this.widget_id, true);					
			}
		]]></method>

		<method name="blinker" args="ignore=null">
			//console.log("Inside blinker");
			this.red.setAttribute('visible',true);
			if(this.playStarted){
				if(gController.dplang.xpathQuery("component[@name='Recorder']") != null){
					var statusText = gController.dplang.xpathQuery("component[@name='Recorder']/playStatusInProgess").childNodes[0].data;
					this.recordStatus.setAttribute('text',statusText);
				}else{
					this.recordStatus.setAttribute('text',"Playing...");
				}
			}else{
				if(gController.dplang.xpathQuery("component[@name='Recorder']") != null){
					var statusText = gController.dplang.xpathQuery("component[@name='Recorder']/recordStatusInProgess").childNodes[0].data;
					this.recordStatus.setAttribute('text',statusText);
				}else{
					this.recordStatus.setAttribute('text','RECORDING...');
				}
			}
		</method>

		<method name="stopblinker" args="methodname">
			console.log("Inside stopblinker");
			/*if(gController.isaudio){
					gController.enableAllAudio();
				}*/
		// Commenting code to enable asset after response is received.
			//gController.enableAllAssets(); 
			this.setAttribute('startRecord',false);
			gController.setAttribute('recordingStopped',true);
			this.red.setAttribute('visible',false);
			this.redReplace.setAttribute('visible',false);
			this.blinkerVal = 0;			//reset this for blinking the red ball
			/*if(!isLinux())
			lz.Timer.removeTimer(leveldel);	//remove activity meter timer 
			else*/
			lz.Timer.removeTimer(linuxLevelDel); 
			this.stopCalled = true;			//let the timer stop first or this attribute will disturb the flow
			this.micState = false;		
			resetActivityMeterHeight();		//for showing zero actvity bar
			if(this.recordStarted || methodname == 'reset') {
				gController.setAttribute("playIfAnswered",true);
				sendRequest(methodname);
				this.green.setAttribute('visible',true);
				if(gController.dplang.xpathQuery("component[@name='Recorder']") != null){
					var statusText = gController.dplang.xpathQuery("component[@name='Recorder']/recordStatusCompleted").childNodes[0].data;
					this.recordStatus.setAttribute('text',statusText);
				}else{
					this.recordStatus.setAttribute('text','AUDIO CAPTURED');
				}
				this.recordStarted = false;
				this.stopCountDownTimer();
				//console.log("Setting stop button disable***",this.playStarted);
				this.stopButton.setAttribute("enabled", false);
			}
		// Changes for Mic Calibration
			if(this.playStarted){
				this.playStarted = false;
				this.playButton.setAttribute("enabled", true);
				stopPlayTimer();
				sendRequest('stopPlay');
				//console.log("setting green to true 2");
				this.green.setAttribute('visible',true);
				if(gController.dplang.xpathQuery("component[@name='Recorder']") != null){
					var statusText = gController.dplang.xpathQuery("component[@name='Recorder']/playStatusStopped").childNodes[0].data;
					this.recordStatus.setAttribute('text',statusText);
				}else{
					this.recordStatus.setAttribute('text',"Audio Stopped");
				}
				//console.log("Setting stop button disable");
				this.stopButton.setAttribute("enabled", false);
				this.playButton.setAttribute("enabled", true);
				//console.log("Setting reset button true");
				this.resetButton.setAttribute("enabled", true);
			}
		</method>

		<method name="reset" args="methodname"><![CDATA[
			//console.log("resetCalled "+this.resetCalled + methodname);
			if(this.resetCalled == false || gController.isplaying == false) {
				if(methodname == 'reset'){
					if(this.recordingCounter <= 2){
						this.recordingCounter =  this.recordingCounter + 1;
				}
					sendRequest(methodname);
					this.requestSent = false;
					if(this.recordingCounter == 3 && !gMicCalibrationScreen.visible){
						this.resetCalled = true;
					}
				// Fix for defect #80811
				if(!gMicCalibrationScreen.visible){
					gController.updateAudioField(this.widget_id, false);
				}
				gController.setAttribute("resetButtonEnable",false);
					
				}
				this.stopCalled = true;			//set true 
				this.micState = false;			//reset this attribute also
				this.blinkerVal = 0;			//reset this for blinking the red ball
				this.totalTime = this.defaultTotalTime;
				if(gController.isplaying == false){
					this.recordButton.setAttribute("enabled", true);
					}
				else{
					this.recordButton.setAttribute("enabled", false);
					}
				this.setAttribute('startRecord',false);
				gController.setAttribute('recordingStopped',false);
				this.green.setAttribute('visible',false);
				this.red.setAttribute('visible',false);
				this.timertext.setAttribute('text',this.totalTime);		
				this.timertext.setAttribute("fgcolor",0x008000);	
				this.recordStatus.setAttribute('text'," ");	
				this.barfilled.setAttribute('width',0);
				this.increment = 0;
				this.playButton.setAttribute("enabled", false);
				this.resetButton.setAttribute("enabled",false);
				//gController.updateAudioField(this.widget_id, false);
				this.whitewrapperOverLay.setAttribute('visible',false);
			}
			
		]]></method>
		
		<method name="startPlay" args="methodname">
			if(methodname == 'play') {
				sendRequest(methodname);
				this.recordStatus.setAttribute("text"," ");	
				this.playStarted = true;  // Changes for Mic Calibration
				this.recordStarted = false;
				this.recordButton.setAttribute("enabled", false);
				this.playButton.setAttribute("enabled", false);
				this.stopButton.setAttribute("enabled", true);	
				this.resetButton.setAttribute("enabled", false);
				this.green.setAttribute('visible',false);
				//this.recordStatus.setAttribute('visible',false);
			}
		</method>
		
		<method name="startCountDownTimer">
//console.log("Inside startCountDownTimer");
			countDownTimer();
			this.green.setAttribute('visible',false);
		</method>

		<method name="countDownTimer" args="ignore=null">
//console.log("Inside countDownTimer");
		<![CDATA[	
			this.totalTime -= 1; 	
			fillBarWithTime(increment);	
			this.resetButton.setAttribute("enabled", false);
			if(this.totalTime <= 0) {
				this.timertext.setAttribute('text',this.totalTime);
				stopblinker('stop');
				return;
			}
		
			if(this.totalTime <= 15) {
				this.timertext.setAttribute('fgcolor',0xff0000);
			}else{
				this.timertext.setAttribute('fgcolor',0x008000);
			}
			this.timertext.setAttribute('text',this.totalTime);
			lz.Timer.resetTimer(countDownDel, 1000);
			//Changes to stop the recording if the student clicks the pause screen when
			//recording is going on.
			if(gController.isWaitPopupOpen == true){
				stopblinker('stop');
				this.resetCalled = false; 
			}
		
		]]>
		</method>
			
		<method name="setStartRecord">
			
			lz.Timer.removeTimer(startRecordDel);
			this.setAttribute('startRecord',true);
			// Fix for defect #80811
			if(!gMicCalibrationScreen.visible){			
				gController.updateAudioField(this.widget_id, true);
			}
			startCountDownTimer();
			blinker();
			this.stopButton.setAttribute("enabled", true);	
		</method>

		<method name="stopCountDownTimer">
//console.log("Inside stopCountDownTimer");
			lz.Timer.removeTimer(countDownDel);
		</method>

		<method name="fillBarWithTime" args="timeInSecs">
			this.barfilled.setAttribute("width",  barfilled.width + increment);
		</method>

		<method name="sendRequest" args="method">
	         
	         var d = audioDset;
	         var p = new LzParam();
	         p.addValue( "method", method, true);
	         p.addValue( "filename", gController.generateAudioFileName(),true);
	         d.setQueryString( p );
	         d.setAttribute("reqtype","POST"); 
	         d.doRequest();
 		</method>

		<method name="handleResponseData" args="d"><![CDATA[
			this.blinkerVal = 0;
			var result = d.childNodes[0].data;
			gController.setAttribute('recorderState',result);
			if(result == 'RECORDING_START'){
			//Debug.write("RECORDING_START..");
				/*if(!this.startRecord)
				lz.Timer.resetTimer(startRecordDel,200);*/
				
			}
			else if (result == 'RECORDING_STOP') {
			//Debug.write("RECORDING_STOP..");
			
				if( gController.isplaying == false && this.resetCalled == false){
						console.log("Setting start over enabled****");
						gController.setAttribute("resetButtonEnable",true);
						this.resetButton.setAttribute("enabled",true);
						this.playButton.setAttribute("enabled", true);
				}
				gController.enableAllAssets(); 
				if(this.totalTime == 0 && this.recordingCounter == 3 && !gMicCalibrationScreen.visible) {
					gController.setAttribute("recordingCompleted",true);
					this.recordButton.setAttribute("enabled", false);
					this.resetButton.setAttribute("enabled", false);
					this.stopButton.setAttribute("enabled", false);
					return;
				}else{
				 if(this.totalTime == 0){
				 	this.recordButton.setAttribute("enabled", true);
				 }
				}
				this.recordButton.setAttribute("enabled", false);
			//Changes for Mic Calibration
				if(this.playStarted){ 
					this.playStarted = false;
				}
				if(this.recordStarted) this.recordStarted = false;
			}else if (result == 'PLAY_START') {
				this.remainingTime = this.getRemainingTime() + 4;
				blinker();
				this.startPlayTimer();
			}
			else {
				Debug.write("Result Default...."+result);	
			}
			//gCommunicator.finishCall(d,audioDset);
			]]>
		</method>

		<handler name="oninit">
			var base = lz.Browser.getInitArg( 'servletUrl' );
			audioDset.setAttribute('src', base + '/SoundRecorder.do');
			if(canvas.capabilities.audio){
				this.setVolume(0);
			}
		</handler>

		<method name="setReferences">
			//Debug.write("setReferences....");
			this.recordButton	= main.content.widgetbuttons.whitewrapper.buttons.recordButton;
			this.stopButton 	= main.content.widgetbuttons.whitewrapper.buttons.stopButton;
			this.playButton 	= main.content.widgetbuttons.whitewrapper.buttons.playButton;
			//this.resetButton 	= main.content.widgetbuttons.whitewrapper.buttons.resetButton;
			this.resetButton 	= main.content.widgetbuttons.whitewrapper.startOver.resetButton;
			this.bar 			= main.content.bar;
			this.barfilled		= main.content.bar.barfilled;
			this.timertext		= main.content.recordtimer.timertext;//recorddisplay.recordtimer.
			this.red			= main.content.recorddisplay.recordicons.red;
			this.green			= main.content.recorddisplay.recordicons.green;
			this.redReplace		= main.content.recorddisplay.recordicons.redReplace;
			this.meterContainer = main.content.recorddisplay.recordicons.meterContainer;
			this.volumeMeter	= main.content.recorddisplay.recordicons.meterContainer.volumebar;
			this.recordIconsView= main.content.recorddisplay.recordicons;
			this.widgetbuttons 	= main.content.widgetbuttons;
			this.recordStatus 	= main.content.recorddisplay.showStatus.recordStatus;
			
		</method>

		<method name="requestError" args="ds">
			_returnError(ds);
		</method>

		<method name="_returnError" args="ds">
			if(gScreens.isOnFeedbackScreen()){
				gCommunicator.finishCall(gXmlHelper.getFeedbackErrorXml(),ds);
			}
			else{
				gCommunicator.finishCall(gXmlHelper.getErrorXml(),ds);
			}
		</method>
		

		<!-- Volumeter Prototype -->
		<method name="updateLevel" args="ignore=null"><![CDATA[
		//console.log("Inside updateLevel");
			//call to external swf object
			getActivityLevel();
			var isMicAttached;
			var level = 0;
			var vMeterHeight = 0;
			var reClaimedMicObj = null;
			
			/*var micArray = lz.FlashUtils.getMicNames();
			Debug.write("Update Level");
			var micIsSet = false;
			
			
			if(this.isVista()) {
				if(micArray.length > 0 && this.micConnected == false) {
					this.myMic = lz.FlashUtils.getObject();
					this.myMic.gain = 100;
					this.myMic.rate = 11;
					this.myMic.setSilenceLevel(0);
					this.myMic.setLoopBack(true);
					this.myMic.setUseEchoSuppression(true); 
					//this.mc.attachAudio(false);				
					//this.mc.attachAudio(this.myMic);
					this.micConnected = true;
				} 			
				else if(flashSystem.Microphone.names.length == 0) {
					this.micConnected = false;
					this.myMic = null;
				}	
			}*/
			
			/*if(this.myMic != null) {
				//console.log("Inside if "+this.mic);
				level = this.myMic.activityLevel;				
			}else{
				//console.log("this.myMic is null");
			}
			*/
			level = gController.microphoneLevel;
			//console.log("level in recorder---->>>",level);
			if(activityArray.length < 16) {
				if(activityArray.length == 15) {
					isMicAttached = activityCalibrate(activityArray); 	
					//console.log("mic attached check in activityCalibrate===",isMicAttached);
				}else{
					if(level <= 0) {
						activityArray.push(level);
					}
					else {
						isMicAttached = true;
					
					}
				}

			}
	                
			if (level < 0) {
				level = 1;
			}

			if (level != this.level) {
				this.setAttribute("level", level);
			}
			gController.setAttribute('isMicPresent',isMicAttached);
			
			/*if(gController.isMicPresent){
				isMicAttached = true;
				this.whitewrapperOverLay.setAttribute('visible',false);
			}else{
				isMicAttached = false;
				if(gMicCalibrationScreen.visible){
						gTooltip_new.hideTooltip ();    
				}else{
						gTooltip.hideTooltip(); 
				}	
				this.whitewrapperOverLay.setAttribute('visible',true);
			}*/

			if(isMicAttached == false) {
				//console.log("inside if");
				this.blinkerVal = 0;
				if(gMicCalibrationScreen.visible){
						gTooltip_new.hideTooltip ();    
				}else{
						gTooltip.hideTooltip(); 
				}
				this.whitewrapperOverLay.setAttribute('visible',true);
				stopblinker('stop');
				this.resetCalled = false;
				this.micState = false;//Changes for defect 65977 
				gRecordingPopup.hideAllRecorderPopups();
			}
			else if(isMicAttached == true) {
				//console.log("Insied else if");			
				this.micState = true;//Changes for defect 65977
					
				//this.meterContainer.setAttribute('visible',true);
				this.whitewrapperOverLay.setAttribute('visible',false);	 
				//console.log("this.recordStarted***",this.recordStarted);				
					if(this.recordStarted == true && this.startRecord == true){
						if(this.blinkerVal >= 3){
							this.toggleRedDisplay();
							this.blinkerVal = 0;
						}
						this.blinkerVal = this.blinkerVal + 1;
					
						vMeterHeight = this.meterContainer.height - this.level * .5;

						if(vMeterHeight < 0) {
							vMeterHeight = 0;
						}
						this.volumeMeter.setAttribute('height', vMeterHeight);
					}
				else {
					//Debug.write("Mic Connected and Record Started.....")
				}
				
				//console.log("this.recordStarted "+this.recordStarted+" this.stopCalled "+this.stopCalled);
				if(this.recordStarted == false && this.stopCalled == true) {
					//console.log("leveldel timer removed********");
					this.micState = false;//when regained connectivity in recording stop mode
					this.blinkerVal = 0;
					return;	
				}
			

			}	

			lz.Timer.resetTimer(leveldel, 100); 
	    ]]>
		</method>
		
		<method name="updateLinux" args="ignore=null"><![CDATA[
			this.micState = true;
			if(this.recordStarted == true){
				if(this.blinkerVal >= 3){
					this.toggleRedDisplay();
					this.blinkerVal = 0;
				}
				this.blinkerVal = this.blinkerVal + 1;
			}
		lz.Timer.resetTimer(linuxLevelDel, 100); 
	    ]]>
		</method>

		<method name="activityCalibrate" args="arrVal"><![CDATA[
			var i = 0;
			var temp = 0;
			for (i = 0; i < arrVal.length; i++){
				temp =  temp + arrVal[i];
				if(temp > 0) {
					//Debug.write("got mic connectivity....");	
					break;				
				}
			}

			this.activityArray = [];
			return temp > 0;
		]]></method>

		<method name="isFakeActivity" args="arrVal"><![CDATA[
			//Debug.write("isFakeActivity..");
			var i = 0;
			var temp = 0;
			var result = true;	
			for (i = 0; i < arrVal.length; i++){
				if(i == 0) {
					temp = arrVal[i];
					continue;				
				}
				if(temp == arrVal[i]) {
					temp = arrVal[i];
				}
				else {
					result = false;
					break;
				}	
			}
			return result;
		]]></method>

		<method name="resetActivityMeterHeight">
			this.volumeMeter.setAttribute('height',this.meterContainer.height);
		</method>
		
		<method name="toggleRedDisplay">
			if(this.red.visible == false) {
				this.redReplace.setAttribute('visible',false);
				this.red.setAttribute('visible',true);
			}else {
				this.redReplace.setAttribute('visible',true);
				this.red.setAttribute('visible',false);
			}
		</method>
		<method name="getRemainingTime">
			return this.defaultTotalTime - this.totalTime;
		</method>
		<method name="startPlayTimer"><![CDATA[
			//Debug.write("startPlayTimer this.remainingTime : "+this.remainingTime);	
			if(typeof this.playDel == "undefined") {
				this.playDel = new lz.Delegate(this, "startPlayTimer");
			}
			if(this.remainingTime == 0) {
				this.stopblinker('stop');
				if(gController.dplang.xpathQuery("component[@name='Recorder']") != null){
					var statusText = gController.dplang.xpathQuery("component[@name='Recorder']/playStatusComplete").childNodes[0].data;
					this.recordStatus.setAttribute('text',statusText);
				}else{
					this.recordStatus.setAttribute("text","Playback Complete");
					  
				}
				
				
				return;
			}
			this.remainingTime -= 1;
			lz.Timer.resetTimer(this.playDel, 1000);
		]]></method>

		<method name="stopPlayTimer">
			lz.Timer.removeTimer(this.playDel);
			this.remainingTime = 0;
		</method>
		
	</class>
</library>