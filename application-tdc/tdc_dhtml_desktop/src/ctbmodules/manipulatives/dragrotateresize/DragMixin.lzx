<library>

    <!--- drag mixin replacing the dragstate functionality for a class. Fixes the
          bug with incorrect drag positions for views contained within scaled
          views in DHTML runtime -->
    <mixin name="DragMixin">

        <!--- scaled width of the view -->
        <attribute name="scaledwidth" type="size" />

        <!--- scaled height of the view -->
        <attribute name="scaledheight" type="size" />

        <!--- if set to true, activates the dragging mode of this view -->
        <attribute name="dragenabled" value="false" type="boolean"/>

        <!--- lz.Idle.onidle delegate used for tracking position changes -->
        <attribute name="__idledel" value="null" />

        <!--- used to control allowed direction of movement: 'x', 'y' or 'both' -->
        <attribute name="dragaxis" value="both" type="string"/>

        <!--- the minimum value for the x attribute. Default : null, no minimum -->
        <attribute name="dragminx" value="null" type="number"/>

        <!--- the maximum value for the x attribute. Default : null, no maximum -->
        <attribute name="dragmaxx" value="null" type="number"/>

        <!--- the minimum value for the y attribute. Default : null, no minimum -->
        <attribute name="dragminy" value="null" type="number"/>

        <!--- the maximum value for the y attribute. Default : null, no maximum -->
        <attribute name="dragmaxy" value="null" type="number"/>

        <!--- @keywords private -->
        <attribute name="__dragxoffset" value="0"/>

        <!--- @keywords private -->
        <attribute name="__dragyoffset" value="0"/>

        <!-- EVENT HANDLERS -->
        <handler name="onwidth">
            setAttribute('scaledwidth', getAttributeRelative('width', canvas));
        </handler>

        <handler name="onheight">
            setAttribute('scaledheight', getAttributeRelative('height', canvas));
        </handler>

        <!--- Enters and leaves drag mode depending on the value of dragenabled. -->
        <handler name="ondragenabled"><![CDATA[
            if (dragenabled) {
                if (this.__idledel == null) {
                    this.__idledel = new LzDelegate(this,
                            "__updateDragPosition");
                }
                lz.Idle.onidle.addDelegate(this.__idledel);
                setAttribute('__dragxoffset', xoffset - __getMouse(this, 'x'));
                setAttribute('__dragyoffset', yoffset - __getMouse(this, 'y'));
            } else {
                lz.Idle.onidle.removeDelegate(this.__idledel);
            }
        ]]>
        </handler>

        <!--- If dragenabled=true, the lz.Idle.onidle event will be passed to this method.
              @keywords private
              -->
        <method name="__updateDragPosition" args="ignore=null"><![CDATA[
            __setNewPos('x', __getMouse(immediateparent, 'x') + __dragxoffset
                            * xscale);
            __setNewPos('y', __getMouse(immediateparent, 'y') + __dragyoffset
                            * yscale);
        ]]>
        </method>

        <!--- Used to update the x/y position.
              @keywords private
              -->
        <method name="__setNewPos" args="axis, newPos"><![CDATA[
            if (dragaxis == axis || dragaxis == 'both') {
                var offset = this['__drag' + axis + 'offset'];
                var min = this['dragmin' + axis];
                var max = this['dragmax' + axis];
                if (min != null && newPos < min)
                    newPos = min;
                if (max != null && newPos > max)
                    newPos = max;
                setAttribute(axis, Math.round(newPos));
            }
        ]]>
        </method>

        <!--- @keywords private -->
        <method name="__getMouse" args="target, axis"> <![CDATA[
            var scale = 1;
            if (axis == 'x') {
                scale = target.getAttributeRelative('width', canvas)
                        / target.width;
            } else if (axis == 'y') {
                scale = target.getAttributeRelative('height', canvas)
                        / target.height;
            }
            if ($as3) {
                return target.getMouse(axis);
            } else {
                return Math.round(target.getMouse(axis) / scale);
            }
        ]]>
        </method>

    </mixin>

</library>
