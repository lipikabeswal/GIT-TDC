package com.ctb.tdc.web.processingAction;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.HashMap;
import java.util.List;

import org.apache.commons.httpclient.HttpStatus;
import org.apache.http.HttpResponse;

import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.FileEntity;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;

import android.content.Context;
import android.os.Environment;
import android.util.Log;

import com.ctb.tdc.web.utils.AuditFile;
import com.ctb.tdc.web.utils.Base64;
import com.ctb.tdc.web.utils.CATEngineProxy;
import com.ctb.tdc.web.utils.LoadTestUtils;
import com.ctb.tdc.web.utils.MemoryCache;
import com.ctb.tdc.web.utils.ServletUtils;

/**
 * @author Tai_Truong
 * 
 *         This supports response persistence and lifecycle events. New events
 *         are only accepted and persisted locally if prior events were
 *         acknowledged by upstream partner, otherwise an error occurs after a
 *         suitable wait/retry cycle. When prior events have been acknowledged
 *         by the TMS, new events generated by the client are acknowledged by
 *         the local servlet as soon as they are securely persisted locally,
 *         allowing the user to continue. Delay (and ultimately, in severe
 *         cases, interruption) of test thus only occur if upstream response
 *         time exceeds user 'think' time. To ensure that no responses are lost,
 *         an error is returned immediately in that case.
 */
public class PersistenceAction {

	

	/**
	 * Constructor of the object.
	 */
	public PersistenceAction() {
		super();
	}

	/**
	 * The handleEvent method of the Action Class. <br>
	 * 
	 * call the method based on each event, return result response xml to client
	 */
	@SuppressWarnings("unused")
	public String handleEvent(String method, String xml) throws IOException {
		String result = ServletUtils.OK;
 		boolean validSettings = ServletUtils.validateServletSettings();
		Double abilityScore = 0.0;
		Double sem = 0.0;
		String xmlRes = null;
		String objScore = "0,0,0,0,0,0";

		// call method to perform an action only if servlet settings is valid
		if (!validSettings)
			result = ServletUtils.getServletSettingsErrorMessage();
		else if (method != null
				&& method.equals(ServletUtils.VERIFY_SETTINGS_METHOD)) {
			result = verifyServletSettings();
		} else if (method != null && method.equals(ServletUtils.LOGIN_METHOD))
			result = login(xml);
		else if (method != null && method.equals(ServletUtils.SAVE_METHOD)) {
			System.out.println(" original save xml:" + xml);
			if (ServletUtils.isCurSubtestAdaptive) {
				String realId = null;
				String adsItemId = ServletUtils.parseAdsItemId(xml);

				if (adsItemId != null && !ServletUtils.NONE.equals(adsItemId)) {
					// realId = (String)
					// ContentServlet.itemSubstitutionMap.get(adsItemId);
					if (realId != null) {
						xml = xml.replaceAll(adsItemId, realId);
					}

				}
				System.out.println(" replaced save xml:" + xml);
				Boolean isStopCat = ServletUtils.isScoreSubtest(xml);
				if (isStopCat) {
					abilityScore = CATEngineProxy.getAbilityScore();
					sem = CATEngineProxy.getSEM();
					objScore = CATEngineProxy.getObjScore();

					xml = LoadTestUtils.setAttributeValue("score.ability",
							abilityScore.toString(), xml);
					xml = LoadTestUtils.setAttributeValue("score.sem",
							sem.toString(), xml);
					xml = LoadTestUtils.setAttributeValue("score.objective",
							objScore, xml);
					System.out.println("Student Stop: "
							+ CATEngineProxy.isStudentStop());

					// setting unscored_items=1 to detect student stop.
					// Changed: Need not do this now
					if (CATEngineProxy.isStudentStop()) {
						xml = LoadTestUtils.setAttributeValue(
								"number_of_unscored_items", "1", xml);
					}
					System.out.println("XML after Integrating: " + xml);
				}
				Integer itemRawScore = getItemRawScoreFromResponse(xml);
				System.out.println("itemRawScore:" + itemRawScore);
				String isCatOver = ServletUtils.parseCatOver(xml);
				String itemresponse = ServletUtils.parseResponse(xml);
				System.out.println("itemResponse: " + itemresponse);
				String marked = ServletUtils.parseCatSave(xml);
				// To check student stop and out of time
				String isCatStop = ServletUtils.parseCatStop(xml);
				if (isCatOver != null
						&& ("false".equals(isCatOver) || ServletUtils.NONE
								.equals(isCatOver))) {

					System.out.println("CurrentItem :"
							+ ServletUtils.currentItem + ":: itemid:" + realId);

					if (itemRawScore != null) {
						if (ServletUtils.currentItem == realId) {
							try {
								System.out.println("inside condition!");
								if (itemresponse != null && itemresponse != "-"
										&& marked != null && "1".equals(marked)) {

									if ((itemresponse.startsWith("undefined") || itemresponse
											.equals(""))
											&& isCatStop.startsWith("true")) {
										CATEngineProxy.scoreCurrentItem(-9,
												false);
									} else if (isCatStop.startsWith("true")
											&& (!itemresponse
													.startsWith("undefined") || !itemresponse
													.equals(""))) {
										CATEngineProxy.scoreCurrentItem(
												itemRawScore.intValue(), true);
									} else {
										CATEngineProxy.scoreCurrentItem(
												itemRawScore.intValue(), false);
									}
								}

							} catch (Exception e) {
								System.out.println("CAT Over!");
								Log.e("CAT Over!","CAT Over!");
								// ServletUtils.writeResponse(response,
								// ServletUtils.buildXmlErrorMessage("CAT OVER",
								// "Ability: " +
								// CATEngineProxy.getAbilityScore() + ", SEM: "
								// + CATEngineProxy.getSEM(), "000"));
								xmlRes = ServletUtils
										.writeResponse(ServletUtils
												.buildXmlErrorMessage(
														"CAT OVER",
														CATEngineProxy
																.getAbilityScore()
																+ "|"
																+ CATEngineProxy
																		.getSEM()
																+ "|"
																+ CATEngineProxy
																		.getObjScore(),
														"000"));
								// CATEngineProxy.deInitCAT();

							}
						}
					}
				}
				result = saveMain(xml);
			} else {
				result = saveMain(xml);
			}
		} else if (method != null
				&& method.equals(ServletUtils.FEEDBACK_METHOD))
			result = feedback(xml);
		else if (method != null
				&& method.equals(ServletUtils.UPLOAD_AUDIT_FILE_METHOD))
			result = uploadAuditFile(xml);
		else if (method != null
				&& method.equals(ServletUtils.WRITE_TO_AUDIT_FILE_METHOD))
			result = writeToAuditFile(xml);
		else
			result = ServletUtils.ERROR;

		// return response to client
		if (result != null) {
			// System.out.println(result);
			String mseq = ServletUtils.parseMseq(xml);
			xmlRes = ServletUtils.writeResponse(result, mseq);
		}
		return xmlRes;
	}

	private Integer getItemRawScoreFromResponse(String xml) {
		try {
			// System.out.println(xml);
			if (xml.indexOf("<rv n=") >= 0) {
				String marked = ServletUtils.parseCatSave(xml);
				System.out.println(" sendcatsave : " + marked);

				if (marked != null && "1".equals(marked)) {
					String itemresponse = ServletUtils.parseResponse(xml);

					String correctResponse = null;// need to change the value of
													// the var
					if (correctResponse.equals(itemresponse)) {
						return Integer.valueOf(1);
					} else {
						return Integer.valueOf(0);
					}
				} else {
					return null;
				}
			} else {
				return null;
			}
		} catch (Exception e) {
			System.out.println("CAT Over!");
			Log.e("CAT Over!","CAT Over!");
			ServletUtils.writeResponse(ServletUtils.buildXmlErrorMessage(
					"CAT OVER", "Ability: " + CATEngineProxy.getAbilityScore()
							+ ", SEM: " + CATEngineProxy.getSEM(), "000"));
			// CATEngineProxy.deInitCAT();
		}
		return null;
	}

	/**
	 * The verifyServletSettings method of the servlet. <br>
	 * 
	 * verify if values in tdc.properties are valid
	 */
	private String verifyServletSettings() {
		String errorMessage = ServletUtils.OK;
		if (!ServletUtils.validateServletSettings()) {
			// return error message if values in properties file are invalid
			errorMessage = ServletUtils.getServletSettingsErrorMessage();
		} else {
			// properties file are valid, now check for TMS connection
			errorMessage = ServletUtils.httpClientGetStatus();
		}
		return errorMessage;
	}

	/**
	 * The login method of the servlet. <br>
	 * 
	 * handle login request from client request login response xml from TMS
	 * process encryptionKey to memory cache parse login response xml to
	 * determine roster id and restart data (if present) return login response
	 * xml from TMS to client
	 * 
	 * @param String
	 *            xml
	 */
	private String login(String xml) {
		String result = ServletUtils.ERROR;

		try {

			result = ServletUtils.httpClientSendRequest(
					ServletUtils.LOGIN_METHOD, xml);

			if (ServletUtils.isLoginStatusOK(result)) {
				// process encryptionKey to memory cache
				ServletUtils.processContentKeys(result);

				// if(ServletUtils.isCurSubtestAdaptive){
				ServletUtils.getConsolidatedRestartData(result);

				// if file exist handle restart
				String fileName = ServletUtils.buildFileName(xml);
				if (AuditFile.exists(fileName)) {
					// handle restart here in phase 2
				}
				// logger.info("Login successfully.");
				processLoginResponse(result);
			} else {
				// logger.error("TMS returns error in login() : " + result);
			}

			/*File speexFile = new File( Environment.getExternalStorageDirectory()  
					+ "//streams//");

			File[] files = speexFile.listFiles();
			System.out.println("files length" + files.length);
			if (files.length > 0) {
				for (int i = 0; i < files.length; i++) {
					files[i].delete();
				}
			}*/

		}

		catch (Exception e) {
			Log.e("Exception occured in login() : "
					, ServletUtils.printStackTrace(e));
			result = ServletUtils.buildXmlErrorMessage("", e.getMessage(), "");
		}
		return result;
	}

	/**
	 * The feedback method of the servlet. <br>
	 * 
	 * handle feedback request from client return feedback response xml from TMS
	 * to client
	 * 
	 * @param String
	 *            xml
	 */
	private String feedback(String xml) {
		String result = ServletUtils.ERROR;
		try {
			// sent feedback request to TMS
			// logger.info("***** studentFeedback request");
			result = ServletUtils.httpClientSendRequest(
					ServletUtils.FEEDBACK_METHOD, xml);
		} catch (Exception e) {
			Log.e("Exception occured in feedback() : "
					, ServletUtils.printStackTrace(e));
			result = ServletUtils.buildXmlErrorMessage("", e.getMessage(), "");
		}
		return result;
	}

	/**
	 * The save method of the servlet. <br>
	 * 
	 * verify the acknowledge from TMS, checking based on values settings in
	 * tdc.properties if acknowledge checking failed, return error to client
	 * '<ERROR />' if acknowledge checking passed, write response to audit file
	 * (if save response), return ack to client, send request to TMS, on
	 * response from TMS, change ack in memory cache.
	 * 
	 * @param HttpServletResponse
	 *            response
	 * @param String
	 *            xml
	 */
	private String saveMain(String xml) {

		String result = null; // must set to null to prevent sending response
								// twice
		String errorMessage = null;
		// parse request xml for information
		String lsid = ServletUtils.parseLsid(xml);
		String mseq = ServletUtils.parseMseq(xml);
		String rosterId = lsid.split(":")[0];
		String itemId = ServletUtils.parseItemId(xml);
		String itemResponse = ServletUtils.parseResponse(xml);
		String fileName = rosterId + "_" + itemId;
		String decodedXml = null;
		String startAnswerTag = null;
		String endAnswerTag = null;
		String decodedItemResponse = null;
		String replacedItemResponse = null;
		String paramXml = xml;
		boolean containsAudioResponse = false;
		String audioResponseString = null;
		String base64String = null;

		try {

			decodedXml = URLDecoder.decode(xml, "UTF-8");

			decodedItemResponse = URLDecoder.decode(itemResponse, "UTF-8");

			String[] answersTags = decodedItemResponse.split(fileName);

			if (answersTags.length > 1) {

				startAnswerTag = URLEncoder.encode(answersTags[0], "UTF-8");
				endAnswerTag = URLEncoder.encode(answersTags[1], "UTF-8");

				base64String = generateBase64String(fileName);

				if (base64String != "") {
					// prepare answer string with actual audio data
					replacedItemResponse = startAnswerTag + "" + base64String
							+ "" + endAnswerTag;
				} else {
					replacedItemResponse = base64String;
				}

				// replace the audio file name with actual audio data
				xml = decodedXml.replaceAll(decodedItemResponse,
						replacedItemResponse);

				containsAudioResponse = true;
			}

			boolean isEndSubtest = ServletUtils.isEndSubtest(xml);

			MemoryCache memoryCache = MemoryCache.getInstance();

			// log an entry into audit file
			boolean hasResponse = ServletUtils.hasResponse(xml);
			if (hasResponse) {
				if (containsAudioResponse) {
					// System.out.println("containsaudioresponse");
					AuditFile.log(ServletUtils.createAuditVO(paramXml,
							hasResponse));
				} else {

					AuditFile.log(ServletUtils.createAuditVO(xml, hasResponse));
				}
			}

			result = save(xml);

		} catch (Exception e) {
			Log.e("mseq " + mseq + ": Exception occured in save() : "
					,e.getMessage());
			e.printStackTrace();
			errorMessage = ServletUtils
					.getErrorMessage("tdc.servlet.error.noAck");
			result = ServletUtils.buildXmlErrorMessage("", errorMessage, "");
		}

		if (fileName != null) {
			if (result == ServletUtils.OK) {
				if (base64String != null) {

					File speexFile = new File(Environment.getExternalStorageDirectory() + ("/")
							+ "//streams//" + fileName + ".spx");

					if (speexFile.exists()) {
						speexFile.delete();
					}
				}
			}
		}
		return result;
	}

	private static String save(String xml) throws Exception {
		String result = null;
		MemoryCache memoryCache = MemoryCache.getInstance();
		String lsid = ServletUtils.parseLsid(xml);
		String mseq = ServletUtils.parseMseq(xml);
		boolean isEndSubtest = ServletUtils.isEndSubtest(xml);
		// send request to TMS
		if (memoryCache.getSrvSettings().isTmsPersist()) {
			// message was added to pending list in cache,
			// send save request to TMS
			String tmsResponse = "";

			// logger.info("mseq " + mseq + ": persistence request");
			tmsResponse = ServletUtils.httpClientSendRequest(
					ServletUtils.SAVE_METHOD, xml);
			if (isEndSubtest) {
				result = tmsResponse;
				ServletUtils.isRestart = false;
				if (ServletUtils.isCurSubtestAdaptive) {
					CATEngineProxy.deInitCAT();
				}
			} else {
				if (ServletUtils.isStatusOK(tmsResponse)) {
					result = ServletUtils.OK;
				}
			}
			boolean hasLev = ServletUtils.hasLev(xml);
			if (hasLev) {
				// space out lifecycle events a little bit
				Thread.sleep(1000);
			}
		}
		return result;
	}

	/**
	 * The writeToAuditFile method of the servlet. <br>
	 * 
	 * write xml model content to audit file
	 * 
	 * @param String
	 *            xml
	 */
	private String writeToAuditFile(String xml) {
		String result = ServletUtils.ERROR;
		String errorMessage = null;
		System.out.println("writeToAuditFile....");
		try {
			// truncate the file if it is bigger than 200 KB before write model
			// content
			String fileName = ServletUtils.buildFileName(xml);
			if (ServletUtils.isFileSizeTooBig(fileName)) {
				// logger.info("Audit file is too big (> 200KB), file will be truncated before writing model data.");
				AuditFile.deleteLogger(fileName);
			}

			// write model content to audit file
			AuditFile.log(ServletUtils.createAuditVO(xml, false));

			// sent writeToAuditFile request to TMS
			// logger.info("***** uploadAuditFile request");
			ServletUtils.httpClientSendRequest(
					ServletUtils.WRITE_TO_AUDIT_FILE_METHOD, xml);
			result = ServletUtils.OK; // nothing return from TMS
		} catch (Exception e) {
			Log.e("Exception occured in writeToAuditFile() : "
					, ServletUtils.printStackTrace(e));
			errorMessage = ServletUtils
					.getErrorMessage("tdc.servlet.error.writeToAuditFileFailed");
			result = ServletUtils.buildXmlErrorMessage("", errorMessage, "");
		}
		return result;
	}

	/**
	 * The uploadAuditFile method of the Action Class. <br>
	 * 
	 * upload the audit file to TMS and delete the file from local storage
	 * 
	 * @param String
	 *            xml
	 */
	private String uploadAuditFile(String xml) {
		synchronized (ServletUtils.client) {
			String result = ServletUtils.ERROR;
			String errorMessage = null;
			int responseCode = HttpStatus.SC_OK;

			MemoryCache memoryCache = MemoryCache.getInstance();
			if (memoryCache.getSrvSettings().isTmsAuditUpload()) {
				// get the audit file to upload
				String fileName = ServletUtils.buildFileName(xml);
				// File file = new File(fileName);
				File file = new File(Context.MODE_PRIVATE + fileName);
				if (file.exists()) {
					// get checksum value
					long sumValue = ServletUtils.getChecksum(file);
					if (sumValue == -1L) {
						// logger.error("Checksum error.");
						return ServletUtils.ERROR;
					}

					// setup URL parameters
					String tmsURL = ServletUtils
							.getTmsURLString(ServletUtils.UPLOAD_AUDIT_FILE_METHOD);
					tmsURL += "?" + ServletUtils.XML_PARAM + "=" + xml;
					tmsURL += "&" + ServletUtils.CHECKSUM_PARAM + "="
							+ sumValue;

					// PostMethod filePost = new PostMethod(tmsURL);
					HttpPost filePost = new HttpPost(tmsURL);
					try {
						FileEntity reqEntity = new FileEntity(file,
								"text/plain");
						filePost.setEntity(reqEntity);

						// set multipart request
						/*
						 * Part[] parts = { new FilePart(
						 * ServletUtils.AUDIT_FILE_PARAM, file) };
						 * filePost.setRequestEntity(new MultipartRequestEntity(
						 * parts, filePost.getParams()));
						 */

						HttpResponse res = ServletUtils.client
								.execute(filePost);

						// delete local file when upload successfully
						if (res.toString().contains("OK")) {

							String tmsResponse = res.toString();

							// if OK return from TMS, delete local file
							if (ServletUtils.isStatusOK(tmsResponse)) {
								// logger.info("Upload audit file successfully");
								if (AuditFile.deleteLogger(fileName)) {
									// logger.info("Delete audit file successfully");
									result = ServletUtils.OK;
								} else {
									// logger.error("Failed to delete audit file");
									errorMessage = ServletUtils
											.getErrorMessage("tdc.servlet.error.deleteAuditFileFailed");
									result = ServletUtils.buildXmlErrorMessage(
											"", errorMessage, "");
								}
							} else {

								errorMessage = ServletUtils
										.getErrorMessage("tdc.servlet.error.uploadFailed");
								result = ServletUtils.buildXmlErrorMessage("",
										errorMessage, "");
							}
						} else {

						result = ServletUtils.buildXmlErrorMessage("",
									HttpStatus.getStatusText(responseCode), "");
						}
					} catch (Exception e) {
						Log.e("Exception occured in uploadAuditFile() : "
								, ServletUtils.printStackTrace(e));
						errorMessage = ServletUtils
								.getErrorMessage("tdc.servlet.error.uploadFailed");
						result = ServletUtils.buildXmlErrorMessage("",
								errorMessage, "");
					} finally {

					}
				} else {
					result = ServletUtils.OK;
				}
			} else {
				// file was already uploaded by another thread
				result = ServletUtils.OK;
			}

			return result;
		}
	}

	/***
	 * generateBase64String() helps in generating the base64 encoded String from
	 * the Audio File
	 * 
	 * 
	 * @return
	 */
	private String generateBase64String(String fileName) {

		// System.out.println("file passed in generateBase64String : " +
		// fileName);
		String base64EncodedString = "";
		try {

			File file = new File(Context.MODE_PRIVATE + ("/") + "//streams//"
					+ fileName + ".spx");

			if (!file.exists()) {

				return base64EncodedString;// file does not exist so return
											// empty string
			}

			FileInputStream fis = new FileInputStream(file);

			ByteArrayOutputStream bos = new ByteArrayOutputStream();
			byte[] buf = new byte[1024];
			try {
				for (int readNum; (readNum = fis.read(buf)) != -1;) {
					bos.write(buf, 0, readNum); // Initial run so no doubt here
												// it's 0
				}
			} catch (IOException ex) {
				ex.printStackTrace();
			}
			bos.close();
			fis.close();

			byte[] bytes = bos.toByteArray();
			base64EncodedString = Base64.encode(bytes);

		} catch (Exception e) {
			Log.e("Base64String Not Generated","Base64String Not Generated");
			e.printStackTrace();
		}
		return base64EncodedString;

	}

	/**
	 * 
	 * Method created to populate the content Download URI from login response
	 * 
	 * @param loginResponse
	 */
	private void processLoginResponse(String loginResponse) {
		// System.out.println("Process Login Response" + loginResponse);
		MemoryCache memCache = MemoryCache.getInstance();
		HashMap contentDownloadMap = new HashMap();
		org.jdom.Document loginReponseDocument = null;
		System.out.println("processLoginResponse");
		SAXBuilder saxBuilder = new SAXBuilder();
		try {
			loginReponseDocument = saxBuilder.build(new ByteArrayInputStream(
					loginResponse.getBytes()));
		} catch (JDOMException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		org.jdom.Element element = (org.jdom.Element) loginReponseDocument
				.getRootElement().getChild("login_response");
		element = element.getChild("manifest");
		if (element != null) {
			List subtestList = element.getChildren("sco");
			for (int i = 0; i < subtestList.size(); i++) {

				element = (org.jdom.Element) subtestList.get(i);
				contentDownloadMap.put(element.getAttributeValue("adsid"),
						element.getAttributeValue("contentURI"));

			}

			memCache.setContentDownloadMap(contentDownloadMap);

		}
	}

}
